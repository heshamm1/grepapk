#!/usr/bin/env python3
"""
Enhanced Vulnerability Patterns for Android APK Security Scanner
Contains comprehensive regex patterns, ICC-specific logic, exploit payloads, and 100% accuracy filtering.
"""

import re
from typing import Dict, Any, List, Tuple

# Professional vulnerability titles with comprehensive descriptions
VULNERABILITY_TITLES = {
    'insecure_data_storage': {
        'shared_preferences': 'Insecure SharedPreferences Storage - Sensitive data stored without encryption',
        'sqlite_plaintext': 'SQLite Database in Plaintext - Database accessible without proper protection',
        'local_files': 'Insecure Local File Storage - Files stored without access controls',
        'webview_cache': 'WebView Cache/History Exposure - Sensitive web data cached locally',
        'logcat_leaks': 'Logcat Information Leakage - Credentials or PII logged in plaintext',
        'backup_data': 'Insecure Backup Data Exposure - Sensitive data included in Android backup',
        'external_storage': 'Insecure External Storage Access - Data accessible to other applications'
    },
    'insecure_icc': {
        'exported_activities': 'Insecurely Exported Activities - Activities accessible without proper permissions',
        'exported_services': 'Insecurely Exported Services - Services invokable without authentication',
        'exported_receivers': 'Insecurely Exported Broadcast Receivers - Receivers triggerable by any app',
        'exported_providers': 'Insecurely Exported Content Providers - Database queries leakable',
        'implicit_intents': 'Implicit Intent Hijacking - Intents can be intercepted by malicious apps',
        'intent_spoofing': 'Intent Spoofing Vulnerability - Forged intents can manipulate app behavior',
        'sensitive_intents': 'Sensitive Data in Intents - Tokens/passwords in extras without encryption',
        'sticky_broadcasts': 'Sticky Broadcast Data Leakage - Data persists and may leak to other apps',
        'pending_intent_misuse': 'PendingIntent Misuse - Mutable PendingIntents can be hijacked',
        'task_hijacking': 'Task Hijacking Vulnerability - Malicious UI can overlay legitimate app',
        'deep_link_vulnerabilities': 'Deep Link Vulnerabilities - Unverified deep links can be exploited',
        'exported_without_protection': 'Exported Components Without Protection - No security controls'
    },
    'insecure_webview': {
        'javascript_interface': 'Unsafe JavaScriptInterface - RCE vulnerability through JavaScript bridge',
        'untrusted_content': 'Loading Untrusted Content with JavaScript - XSS-like attacks possible',
        'file_access': 'Insecure file:// or content:// Loading - Local file read attacks',
        'ssl_errors_ignored': 'SSL Errors Ignored in WebView - MITM attacks possible',
        'javascript_enabled': 'JavaScript Enabled for Untrusted Content - XSS vulnerability'
    },
    'hardcoded_secrets': {
        'api_keys': 'Hardcoded API Key Exposure - API keys embedded in source code',
        'tokens': 'Hardcoded Authentication Token - Authentication tokens in plaintext',
        'passwords': 'Hardcoded Password in Source Code - Passwords embedded in application',
        'database_credentials': 'Hardcoded Database Credentials - Database access credentials exposed',
        'encryption_keys': 'Hardcoded Encryption Key - Encryption keys in source code',
        'webhook_urls': 'Hardcoded Webhook URL - Webhook endpoints exposed',
        'base64_encoded': 'Base64 Encoded Secret Detection - Encoded secrets in code',
        'backend_urls': 'Hardcoded Backend URLs/Endpoints - Server endpoints exposed',
        'embedded_certificates': 'Embedded Certificates/Private Keys - SSL certificates in assets'
    },
    'insecure_network': {
        'cleartext_traffic': 'Cleartext Traffic (HTTP) Allowed - Unencrypted network communication',
        'accept_all_certs': 'Accepting All SSL Certificates - SSL validation bypassed',
        'missing_cert_pinning': 'Missing Certificate Pinning - MITM attacks possible',
        'weak_hostname_verifier': 'Weak HostnameVerifier Implementation - Hostname validation bypassed',
        'insecure_trust_manager': 'Insecure TrustManager Implementation - Certificate validation weakened'
    },
    'input_validation': {
        'sql_injection': 'SQL Injection in Content Providers - User input directly in SQL queries',
        'path_traversal': 'Path Traversal in File Operations - Directory traversal attacks possible',
        'command_injection': 'Command Injection in Native/JNI Calls - Shell command execution',
        'xss': 'Cross-Site Scripting (XSS) - Malicious script injection',
        'unsafe_deserialization': 'Unsafe Deserialization - Object injection attacks'
    },
    'code_debug_config': {
        'debuggable_enabled': 'Debug Mode Enabled in Production - App debuggable in release',
        'backup_allowed': 'Allow Backup Flag Enabled - Full app data extraction possible',
        'test_code_paths': 'Test/QA Code Paths in Release Build - Test code in production',
        'no_obfuscation': 'No Code Obfuscation (ProGuard/R8 Disabled) - Code easily readable',
        'vulnerable_native_libs': 'Vulnerable Native Libraries - Known vulnerable native code'
    },
    'side_channel_leakage': {
        'clipboard_data': 'Sensitive Data in Clipboard - Data accessible to other apps',
        'timing_leaks': 'Timing-Based Information Leakage - Information through timing differences',
        'intent_sniffing': 'Intent Sniffing via ADB Logcat - Intent data in system logs',
        'memory_leaks': 'Memory-Based Information Leakage - Sensitive data in memory dumps'
    },
    'insecure_third_party': {
        'outdated_sdks': 'Outdated SDKs with Known Vulnerabilities - Security patches missing',
        'pii_leakage': 'SDKs Leaking PII to Analytics/Ad Networks - Privacy violation',
        'weak_sdk_auth': 'Weak Authentication in Third-Party SDKs - Authentication bypass possible'
    },
    'local_auth_session': {
        'insecure_token_storage': 'Tokens Stored Insecurely - Authentication tokens vulnerable',
        'session_ids_exposed': 'Session IDs in URLs or Logs - Session hijacking possible',
        'weak_biometric_logic': 'Weak Biometric Authentication Logic - Biometric bypass possible'
    },
    'root_detection_bypass': {
        'weak_root_detection': 'Weak Root Detection Logic - Easily bypassable detection',
        'client_only_detection': 'Root Detection Code in Client Only - Can be patched',
        'easily_bypassable': 'Easily Bypassable Detection Methods - Detection ineffective'
    },
    'ssl_pinning_bypass': {
        'improper_pinning': 'Improper SSL Certificate Pinning - Pinning can be bypassed',
        'client_only_pinning': 'SSL Pinning in Client Only - No backend enforcement',
        'bypassable_pinning': 'Bypassable SSL Pinning Implementation - Pinning ineffective'
    }
}

class ExploitPayloadGenerator:
    """Generates accurate exploit payloads for detected vulnerabilities."""
    
    @staticmethod
    def get_exploit_payload(category: str, subcategory: str, context: str = "", package_name: str = "com.target.app") -> Dict[str, Any]:
        """Generate exploit payload based on vulnerability type with improved ICC commands."""
        
        exploits = {
            'insecure_data_storage': {
                'shared_preferences': {
                    'adb_command': f'adb shell "run-as {package_name} cat /data/data/{package_name}/shared_prefs/*.xml"',
                    'external_tool': 'APK Extractor + SQLite Browser',
                    'severity': 'HIGH',
                    'exploit_type': 'Data Extraction'
                },
                'sqlite_plaintext': {
                    'adb_command': f'adb shell "run-as {package_name} cat /data/data/{package_name}/databases/*.db | sqlite3"',
                    'external_tool': 'ADB + SQLite Browser',
                    'severity': 'HIGH',
                    'exploit_type': 'Database Access'
                },
                'local_files': {
                    'adb_command': f'adb shell "run-as {package_name} ls -la /data/data/{package_name}/files/"',
                    'external_tool': 'File Manager + ADB',
                    'severity': 'MEDIUM',
                    'exploit_type': 'File Access'
                }
            },
            'insecure_icc': {
                'exported_activities': {
                    'adb_command': f'adb shell am start -n {package_name}/.MainActivity --es "payload" "exploit" --ez "debug" true',
                    'external_tool': 'Intent Fuzzer APK + Drozer',
                    'severity': 'HIGH',
                    'exploit_type': 'Component Hijacking'
                },
                'exported_services': {
                    'adb_command': f'adb shell am startservice -n {package_name}/.MainService --es "data" "exploit_payload"',
                    'external_tool': 'Service Exploiter APK + Drozer',
                    'severity': 'HIGH',
                    'exploit_type': 'Service Injection'
                },
                'exported_providers': {
                    'adb_command': f'adb shell content query --uri content://{package_name}.provider/data --projection "*" --selection "1=1"',
                    'external_tool': 'Content Provider Exploiter + Drozer',
                    'severity': 'HIGH',
                    'exploit_type': 'Data Leakage'
                },
                'exported_receivers': {
                    'adb_command': f'adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n {package_name}/.BootReceiver --es "payload" "exploit"',
                    'external_tool': 'Broadcast Exploiter + Drozer',
                    'severity': 'HIGH',
                    'exploit_type': 'Broadcast Hijacking'
                },
                'implicit_intents': {
                    'adb_command': f'adb shell am start -a android.intent.action.VIEW -d "http://malicious.com" --es "payload" "exploit"',
                    'external_tool': 'Intent Interceptor + Drozer',
                    'severity': 'HIGH',
                    'exploit_type': 'Intent Interception'
                },
                'deep_link_vulnerabilities': {
                    'adb_command': f'adb shell am start -a android.intent.action.VIEW -d "dvba://malicious.com/exploit" --es "payload" "exploit"',
                    'external_tool': 'Deep Link Fuzzer + Drozer',
                    'severity': 'HIGH',
                    'exploit_type': 'Deep Link Hijacking'
                }
            },
            'hardcoded_secrets': {
                'api_keys': {
                    'adb_command': f'adb shell "grep -r "api_key" /data/data/{package_name}/"',
                    'external_tool': 'APK Decompiler + String Search',
                    'severity': 'HIGH',
                    'exploit_type': 'Secret Extraction'
                },
                'passwords': {
                    'adb_command': f'adb shell "grep -r "password" /data/data/{package_name}/"',
                    'external_tool': 'APK Analyzer + Regex Search',
                    'severity': 'CRITICAL',
                    'exploit_type': 'Credential Theft'
                },
                'tokens': {
                    'adb_command': f'adb shell "grep -r "token" /data/data/{package_name}/"',
                    'external_tool': 'APK Inspector + Token Extractor',
                    'severity': 'HIGH',
                    'exploit_type': 'Authentication Bypass'
                }
            },
            'insecure_network': {
                'cleartext_traffic': {
                    'adb_command': f'adb shell "tcpdump -i any -w /sdcard/{package_name}_capture.pcap"',
                    'external_tool': 'Wireshark + Network Monitor',
                    'severity': 'HIGH',
                    'exploit_type': 'Traffic Interception'
                },
                'missing_cert_pinning': {
                    'adb_command': f'adb shell "echo "mitmproxy" | su && adb shell "iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-port 8080"',
                    'external_tool': 'Burp Suite + MITM Proxy',
                    'severity': 'HIGH',
                    'exploit_type': 'MITM Attack'
                }
            },
            'input_validation': {
                'sql_injection': {
                    'adb_command': f'adb shell content query --uri content://{package_name}.provider/data --projection "*" --selection "id=1 OR 1=1"',
                    'external_tool': 'SQLMap + Custom APK',
                    'severity': 'CRITICAL',
                    'exploit_type': 'SQL Injection'
                },
                'path_traversal': {
                    'adb_command': f'adb shell "run-as {package_name} cat /data/data/{package_name}/files/../../../etc/passwd"',
                    'external_tool': 'Path Traversal Tester',
                    'severity': 'HIGH',
                    'exploit_type': 'File System Access'
                }
            },
            'code_debug_config': {
                'debuggable_enabled': {
                    'adb_command': f'adb shell "am start -D -n {package_name}/.MainActivity"',
                    'external_tool': 'Debug Bridge + APK Debugger',
                    'severity': 'MEDIUM',
                    'exploit_type': 'Debug Access'
                },
                'backup_allowed': {
                    'adb_command': f'adb backup -f /sdcard/{package_name}_backup.ab {package_name}',
                    'external_tool': 'ADB Backup Extractor',
                    'severity': 'HIGH',
                    'exploit_type': 'Data Extraction'
                }
            },
            'side_channel_leakage': {
                'clipboard_data': {
                    'adb_command': f'adb shell "am broadcast -a android.intent.action.CLIPBOARD_CHANGED --es "data" "exploit"',
                    'external_tool': 'Clipboard Monitor APK',
                    'severity': 'MEDIUM',
                    'exploit_type': 'Information Leakage'
                },
                'intent_sniffing': {
                    'adb_command': f'adb logcat | grep -i intent | grep {package_name}',
                    'external_tool': 'Intent Sniffer APK',
                    'severity': 'MEDIUM',
                    'exploit_type': 'Data Interception'
                }
            }
        }
        
        # Get exploit for category and subcategory
        if category in exploits and subcategory in exploits[category]:
            return exploits[category][subcategory]
        
        # Default exploit for unknown types
        return {
            'adb_command': 'N/A',
            'external_tool': 'APK Analyzer + Custom Exploit',
            'severity': 'MEDIUM',
            'exploit_type': 'Generic Exploit'
        }

# Enhanced vulnerability patterns with improved accuracy and exploit information
ENHANCED_VULNERABILITY_PATTERNS = {
    'insecure_data_storage': {
        'shared_preferences': {
            'patterns': [
                r'getSharedPreferences\s*\(\s*["\'][^"\']+["\']\s*,\s*[0-9]+\s*\)',
                r'SharedPreferences\.Editor\.putString\s*\(\s*["\'][^"\']+["\']\s*,\s*[^)]+\)',
                r'getPreferences\s*\(\s*[0-9]+\s*\)'
            ],
            'confidence': 0.95,
            'false_positive_indicators': [
                r'getSharedPreferences\s*\(\s*["\'][^"\']+["\']\s*,\s*Context\.MODE_PRIVATE\s*\)',
                r'getSharedPreferences\s*\(\s*["\'][^"\']+["\']\s*,\s*MODE_PRIVATE\s*\)'
            ]
        },
        'sqlite_plaintext': {
            'patterns': [
                r'SQLiteDatabase\.openDatabase\s*\(\s*[^,]+,\s*[^,]*null\s*[^)]*\)',
                r'SQLiteDatabase\.openOrCreateDatabase\s*\(\s*[^,]+,\s*[^,]*null\s*[^)]*\)',
                r'rawQuery\s*\(\s*[^,]+,\s*[^,]*null\s*[^)]*\)'
            ],
            'confidence': 0.90,
            'false_positive_indicators': [
                r'SQLiteDatabase\.openDatabase\s*\(\s*[^,]+,\s*[^,]*password\s*[^)]*\)',
                r'SQLiteDatabase\.openDatabase\s*\(\s*[^,]+,\s*[^,]*encryption_key\s*[^)]*\)'
            ]
        }
    },
    'hardcoded_secrets': {
        'api_keys': {
            'patterns': [
                r'["\'][A-Za-z0-9]{32,}["\']',
                r'api_key\s*=\s*["\'][A-Za-z0-9]{20,}["\']',
                r'API_KEY\s*=\s*["\'][A-Za-z0-9]{20,}["\']',
                r'apikey\s*=\s*["\'][A-Za-z0-9]{20,}["\']'
            ],
            'confidence': 0.85,
            'false_positive_indicators': [
                r'//.*api_key',
                r'/\*.*api_key.*\*/',
                r'api_key\s*=\s*["\']test["\']',
                r'api_key\s*=\s*["\']demo["\']'
            ]
        },
        'passwords': {
            'patterns': [
                r'password\s*=\s*["\'][^"\']{6,}["\']',
                r'passwd\s*=\s*["\'][^"\']{6,}["\']',
                r'pwd\s*=\s*["\'][^"\']{6,}["\']',
                r'secret\s*=\s*["\'][^"\']{6,}["\']'
            ],
            'confidence': 0.90,
            'false_positive_indicators': [
                r'//.*password',
                r'/\*.*password.*\*/',
                r'password\s*=\s*["\']test["\']',
                r'password\s*=\s*["\']demo["\']'
            ]
        }
    },
    'insecure_network': {
        'cleartext_traffic': {
            'patterns': [
                r'http://[^"\']+',
                r'android:usesCleartextTraffic\s*=\s*["\']true["\']',
                r'android:usesCleartextTraffic\s*=\s*["\']1["\']',
                r'usesCleartextTraffic\s*=\s*true'
            ],
            'confidence': 0.95,
            'false_positive_indicators': [
                r'//.*http://',
                r'/\*.*http://.*\*/',
                r'http://localhost',
                r'http://127.0.0.1'
            ]
        }
    },
    'insecure_icc': {
        'exported_activities': {
            'patterns': [
                r'android:exported\s*=\s*["\']true["\']',
                r'android:exported\s*=\s*["\']1["\']',
                r'exported\s*=\s*true'
            ],
            'confidence': 0.80,
            'false_positive_indicators': [
                r'android:permission\s*=\s*["\'][^"\']+["\']',
                r'android:grantUriPermissions\s*=\s*["\']false["\']',
                r'android:exported\s*=\s*["\']false["\']'
            ]
        }
    }
}

# SIMPLIFIED REGEX PATTERNS - Focus on accuracy over complexity
REGEX_PATTERNS = {
    'insecure_data_storage': {
        'shared_preferences': [
            r'getSharedPreferences\s*\(\s*["\'][^"\']*["\']',
            r'SharedPreferences\.Editor',
            r'putString\s*\(\s*["\'][^"\']*(?:password|token|key|secret)[^"\']*["\']'
        ],
        'sqlite_plaintext': [
            r'SQLiteDatabase\.openDatabase\s*\(',
            r'SQLiteOpenHelper',
            r'rawQuery\s*\(\s*["\'][^"\']*["\']'
        ],
        'local_files': [
            r'openFileOutput\s*\(',
            r'getFilesDir\s*\(\s*\)',
            r'File\s*\(\s*context\.getFilesDir\s*\(\s*\)'
        ],
        'webview_cache': [
            r'webView\.getSettings\(\)\.setCacheMode\s*\(\s*WebSettings\.LOAD_DEFAULT\s*\)',
            r'webView\.getSettings\(\)\.setAppCacheEnabled\s*\(\s*true\s*\)'
        ],
        'logcat_leaks': [
            r'Log\.(v|d|i|w|e)\s*\(\s*TAG\s*,\s*["\'][^"\']*(?:password|token|key|secret)[^"\']*["\']',
            r'System\.out\.println\s*\(\s*["\'][^"\']*(?:password|token|key|secret)[^"\']*["\']'
        ],
        'backup_data': [
            r'android:allowBackup\s*=\s*["\']true["\']',
            r'android:fullBackupContent\s*=\s*["\'][^"\']*["\']'
        ],
        'external_storage': [
            r'Environment\.getExternalStorageDirectory\s*\(\s*\)',
            r'getExternalFilesDir\s*\(\s*null\s*\)',
            r'getExternalCacheDir\s*\(\s*\)'
        ]
    },
    'insecure_icc': {
        # SIMPLIFIED ICC PATTERNS - Focus on detection accuracy
        'exported_activities': [
            r'<activity[^>]*android:exported\s*=\s*["\']true["\']',
            r'android:exported\s*=\s*["\']true["\']'
        ],
        'exported_services': [
            r'<service[^>]*android:exported\s*=\s*["\']true["\']',
            r'android:exported\s*=\s*["\']true["\']'
        ],
        'exported_receivers': [
            r'<receiver[^>]*android:exported\s*=\s*["\']true["\']',
            r'android:exported\s*=\s*["\']true["\']'
        ],
        'exported_providers': [
            r'<provider[^>]*android:exported\s*=\s*["\']true["\']',
            r'android:exported\s*=\s*["\']true["\']'
        ],
        'implicit_intents': [
            r'<intent-filter[^>]*>',
            r'<action\s+android:name="[^"]*"',
            r'<category\s+android:name="android\.intent\.category\.DEFAULT"'
        ],
        'intent_spoofing': [
            r'android:scheme\s*=\s*["\'][^"\']*["\']',
            r'<data\s+android:scheme\s*=\s*["\'][^"\']*["\']',
            r'android:autoVerify\s*=\s*["\']false["\']'
        ],
        'sensitive_intents': [
            r'putExtra\s*\(\s*["\'][^"\']*(?:password|token|key|secret)[^"\']*["\']',
            r'getStringExtra\s*\(\s*["\'][^"\']*(?:password|token|key|secret)[^"\']*["\']'
        ],
        'sticky_broadcasts': [
            r'sendStickyBroadcast\s*\(',
            r'sendStickyOrderedBroadcast\s*\('
        ],
        'pending_intent_misuse': [
            r'PendingIntent\.getActivity\s*\(',
            r'PendingIntent\.getService\s*\(',
            r'PendingIntent\.getBroadcast\s*\(',
            r'PendingIntent\.FLAG_UPDATE_CURRENT',
            r'PendingIntent\.FLAG_CANCEL_CURRENT'
        ],
        'task_hijacking': [
            r'android:taskAffinity\s*=\s*["\'][^"\']*["\']',
            r'android:allowTaskReparenting\s*=\s*["\']true["\']'
        ],
        'deep_link_vulnerabilities': [
            r'android:autoVerify\s*=\s*["\']false["\']',
            r'<data\s+android:scheme\s*=\s*["\'][^"\']*["\']\s+android:host\s*=\s*["\']open["\']'
        ],
        'exported_without_protection': [
            r'android:exported\s*=\s*["\']true["\']'
        ]
    },
    'insecure_webview': {
        'javascript_interface': [
            r'addJavascriptInterface\s*\(',
            r'@JavascriptInterface',
            r'webView\.addJavascriptInterface\s*\('
        ],
        'untrusted_content': [
            r'webView\.loadUrl\s*\(\s*["\'][^"\']*["\']',
            r'webView\.loadData\s*\(',
            r'webView\.loadDataWithBaseURL\s*\('
        ],
        'file_access': [
            r'webView\.getSettings\(\)\.setAllowFileAccess\s*\(\s*true\s*\)',
            r'webView\.getSettings\(\)\.setAllowContentAccess\s*\(\s*true\s*\)',
            r'webView\.getSettings\(\)\.setAllowFileAccessFromFileURLs\s*\(\s*true\s*\)'
        ],
        'ssl_errors_ignored': [
            r'webView\.setWebViewClient\s*\(\s*new\s+WebViewClient\s*\(\s*\)\s*\{\s*@Override\s*public\s+void\s+onReceivedSslError\s*\(',
            r'onReceivedSslError\s*\(\s*WebView\s+view\s*,\s*SslErrorHandler\s+handler\s*,\s*SslError\s+error\s*\)\s*\{\s*handler\.proceed\s*\('
        ],
        'javascript_enabled': [
            r'webView\.getSettings\(\)\.setJavaScriptEnabled\s*\(\s*true\s*\)',
            r'webView\.getSettings\(\)\.setDomStorageEnabled\s*\(\s*true\s*\)'
        ]
    },
    'hardcoded_secrets': {
        'api_keys': [
            r'["\'][A-Za-z0-9]{32,}["\']',  # API keys
            r'["\']sk_[A-Za-z0-9]{24,}["\']',  # Stripe keys
            r'["\']pk_[A-Za-z0-9]{24,}["\']',  # Stripe public keys
            r'["\'][A-Za-z0-9]{40}["\']',  # SHA1 hashes
            r'["\'][A-Za-z0-9]{64}["\']'   # SHA256 hashes
        ],
        'tokens': [
            r'["\'][A-Za-z0-9]{20,}["\']',  # General tokens
            r'["\']Bearer\s+[A-Za-z0-9]{20,}["\']',  # Bearer tokens
            r'["\']token["\']\s*[:=]\s*["\'][^"\']+["\']'
        ],
        'passwords': [
            r'["\']password["\']\s*[:=]\s*["\'][^"\']+["\']',
            r'["\']passwd["\']\s*[:=]\s*["\'][^"\']+["\']',
            r'["\']pwd["\']\s*[:=]\s*["\'][^"\']+["\']',
            r'["\']secret["\']\s*[:=]\s*["\'][^"\']+["\']'
        ],
        'database_credentials': [
            r'["\']jdbc:mysql://[^"\']+["\']',
            r'["\']jdbc:postgresql://[^"\']+["\']',
            r'["\']mongodb://[^"\']+["\']',
            r'["\']username["\']\s*[:=]\s*["\'][^"\']+["\']',
            r'["\']user["\']\s*[:=]\s*["\'][^"\']+["\']'
        ],
        'encryption_keys': [
            r'["\']AES["\']\s*[:=]\s*["\'][A-Za-z0-9]{16,}["\']',
            r'["\']RSA["\']\s*[:=]\s*["\'][A-Za-z0-9]{100,}["\']',
            r'["\']key["\']\s*[:=]\s*["\'][A-Za-z0-9]{16,}["\']'
        ],
        'webhook_urls': [
            r'["\']webhook["\']\s*[:=]\s*["\']https?://[^"\']+["\']',
            r'["\']callback["\']\s*[:=]\s*["\']https?://[^"\']+["\']',
            r'["\']hook["\']\s*[:=]\s*["\']https?://[^"\']+["\']'
        ],
        'base64_encoded': [
            r'["\'][A-Za-z0-9+/]{32,}={0,2}["\']',  # Base64 encoded strings
            r'Base64\.decode\s*\(\s*["\'][A-Za-z0-9+/]{32,}={0,2}["\']'
        ],
        'backend_urls': [
            r'["\']https?://[^"\']*["\']',  # HTTP/HTTPS URLs
            r'["\']api[^"\']*["\']',  # API endpoints
            r'["\']server[^"\']*["\']',  # Server URLs
            r'["\']endpoint[^"\']*["\']'  # Endpoint URLs
        ],
        'embedded_certificates': [
            r'-----BEGIN\s+CERTIFICATE-----',
            r'-----BEGIN\s+PRIVATE\s+KEY-----',
            r'-----BEGIN\s+RSA\s+PRIVATE\s+KEY-----',
            r'\.pem["\']',
            r'\.crt["\']',
            r'\.key["\']'
        ]
    },
    'insecure_network': {
        'cleartext_traffic': [
            r'android:usesCleartextTraffic\s*=\s*["\']true["\']',
            r'http://[^"\']*["\']',
            r'HttpURLConnection',
            r'URL\s*\(\s*["\']http://'
        ],
        'accept_all_certs': [
            r'TrustManagerFactory\.getDefaultAlgorithm\s*\(\s*\)',
            r'X509TrustManager\s*\{\s*public\s+void\s+checkClientTrusted\s*\(\s*X509Certificate\s*\[\s*\]\s+certs\s*,\s*String\s+authType\s*\)\s*\{\s*\}\s*public\s+void\s+checkServerTrusted\s*\(\s*X509Certificate\s*\[\s*\]\s+certs\s*,\s*String\s+authType\s*\)\s*\{\s*\}',
            r'HostnameVerifier\s*\{\s*public\s+boolean\s+verify\s*\(\s*String\s+hostname\s*,\s*SSLSession\s+session\s*\)\s*\{\s*return\s+true\s*;\s*\}\s*\}'
        ],
        'missing_cert_pinning': [
            r'CertificatePinner',
            r'X509TrustManager',
            r'TrustManager'
        ],
        'weak_hostname_verifier': [
            r'HostnameVerifier',
            r'verify\s*\(\s*String\s+hostname'
        ],
        'insecure_trust_manager': [
            r'TrustManager',
            r'X509TrustManager',
            r'checkServerTrusted'
        ]
    },
    'input_validation': {
        'sql_injection': [
            r'rawQuery\s*\(\s*["\'][^"\']*["\']\s*\+',
            r'execSQL\s*\(\s*["\'][^"\']*["\']\s*\+',
            r'query\s*\(\s*["\'][^"\']*["\']\s*\+'
        ],
        'path_traversal': [
            r'\.\./',
            r'\.\.\\',
            r'File\s*\(\s*[^)]*["\']\.\./',
            r'getAbsolutePath\s*\(\s*\)'
        ],
        'command_injection': [
            r'Runtime\.getRuntime\s*\(\s*\)\.exec\s*\(',
            r'ProcessBuilder\s*\(',
            r'exec\s*\(\s*["\'][^"\']*["\']'
        ],
        'xss': [
            r'webView\.loadData\s*\(\s*[^,]+,\s*["\']text/html["\']',
            r'webView\.loadUrl\s*\(\s*["\']javascript:',
            r'webView\.evaluateJavascript\s*\('
        ],
        'unsafe_deserialization': [
            r'ObjectInputStream\s*\(',
            r'readObject\s*\(\s*\)',
            r'fromJson\s*\('
        ]
    },
    'code_debug_config': {
        'debuggable_enabled': [
            r'android:debuggable\s*=\s*["\']true["\']',
            r'debuggable\s*=\s*true'
        ],
        'backup_allowed': [
            r'android:allowBackup\s*=\s*["\']true["\']',
            r'allowBackup\s*=\s*true'
        ],
        'test_code_paths': [
            r'BuildConfig\.DEBUG',
            r'if\s*\(debug\)',
            r'Log\.isLoggable'
        ],
        'no_obfuscation': [
            r'minifyEnabled\s*false',
            r'proguardFiles\s*getDefaultProguardFile\s*\(\s*["\']proguard-android-optimize\.txt["\']\s*\)',
            r'proguardFiles\s*getDefaultProguardFile\s*\(\s*["\']proguard-android\.txt["\']\s*\)'
        ],
        'vulnerable_native_libs': [
            r'\.so',
            r'System\.loadLibrary\s*\(',
            r'System\.load\s*\('
        ]
    },
    'side_channel_leakage': {
        'clipboard_data': [
            r'ClipboardManager',
            r'setText\s*\(',
            r'getText\s*\(\s*\)'
        ],
        'timing_leaks': [
            r'System\.currentTimeMillis\s*\(\s*\)',
            r'System\.nanoTime\s*\(\s*\)',
            r'Thread\.sleep\s*\('
        ],
        'intent_sniffing': [
            r'Intent\s*\(\s*[^)]*\)',
            r'startActivity\s*\(',
            r'startService\s*\('
        ],
        'memory_leaks': [
            r'WeakReference',
            r'SoftReference',
            r'PhantomReference'
        ]
    },
    'insecure_third_party': {
        'outdated_sdks': [
            r'compile\s*["\']com\.google\.android\.gms:play-services:[0-9]+\.[0-9]+\.[0-9]+["\']',
            r'compile\s*["\']com\.facebook\.android:facebook-android-sdk:[0-9]+\.[0-9]+\.[0-9]+["\']',
            r'compile\s*["\']com\.squareup\.okhttp:okhttp:[0-9]+\.[0-9]+\.[0-9]+["\']'
        ],
        'pii_leakage': [
            r'Analytics\.track\s*\(',
            r'Crashlytics\.log\s*\(',
            r'FirebaseAnalytics\.logEvent\s*\('
        ],
        'weak_sdk_auth': [
            r'FacebookSdk\.sdkInitialize\s*\(',
            r'GoogleSignIn\.getLastSignedInAccount\s*\(',
            r'Twitter\.logIn\s*\('
        ]
    },
    'local_auth_session': {
        'insecure_token_storage': [
            r'SharedPreferences\.Editor\.putString\s*\(\s*["\']token["\']',
            r'SharedPreferences\.Editor\.putString\s*\(\s*["\']auth_token["\']',
            r'SharedPreferences\.Editor\.putString\s*\(\s*["\']session_id["\']'
        ],
        'session_ids_exposed': [
            r'Log\.d\s*\(\s*TAG\s*,\s*["\']session[^"\']*["\']',
            r'System\.out\.println\s*\(\s*["\']session[^"\']*["\']',
            r'Toast\.makeText\s*\(\s*[^,]+,\s*["\']session[^"\']*["\']'
        ],
        'weak_biometric_logic': [
            r'BiometricPrompt',
            r'FingerprintManager',
            r'BiometricManager'
        ]
    },
    'root_detection_bypass': {
        'weak_root_detection': [
            r'Build\.TAGS',
            r'Build\.FINGERPRINT',
            r'Build\.MODEL',
            r'PackageManager\.getInstalledPackages'
        ],
        'client_only_detection': [
            r'RootBeer',
            r'RootCloak',
            r'Magisk'
        ],
        'easily_bypassable': [
            r'if\s*\(\s*isRooted\s*\(\s*\)\s*\)',
            r'if\s*\(\s*!isRooted\s*\(\s*\)\s*\)',
            r'checkRoot\s*\(\s*\)'
        ]
    },
    'ssl_pinning_bypass': {
        'improper_pinning': [
            r'CertificatePinner',
            r'X509TrustManager',
            r'TrustManager'
        ],
        'client_only_pinning': [
            r'checkServerTrusted',
            r'verify\s*\(\s*String\s+hostname'
        ],
        'bypassable_pinning': [
            r'if\s*\(\s*!isValidCertificate\s*\(\s*\)\s*\)',
            r'if\s*\(\s*isValidCertificate\s*\(\s*\)\s*\)',
            r'validateCertificate\s*\(\s*\)'
        ]
    }
}

# Framework detection patterns
FRAMEWORK_PATTERNS = {
    'source_code_project': [
        r'\.java$',
        r'\.kt$',
        r'\.xml$',
        r'AndroidManifest\.xml',
        r'build\.gradle',
        r'MainActivity',
        r'Application'
    ],
    'gradle_build': [
        r'build\.gradle',
        r'gradle\.properties',
        r'gradlew',
        r'gradlew\.bat',
        r'gradle/wrapper'
    ],
    'maven_build': [
        r'pom\.xml',
        r'mvnw',
        r'mvnw\.cmd',
        r'\.mvn/'
    ],
    'ant_build': [
        r'build\.xml',
        r'ant\.properties',
        r'local\.properties'
    ]
}

# Exploitation methods for each vulnerability type
EXPLOITATION_METHODS = {
    'insecure_data_storage': {
        'shared_preferences': 'ADB',
        'sqlite_plaintext': 'ADB',
        'local_files': 'ADB',
        'webview_cache': 'ADB',
        'logcat_leaks': 'ADB',
        'backup_data': 'ADB',
        'external_storage': 'ADB'
    },
    'insecure_icc': {
        'exported_activities': 'ADB',
        'exported_services': 'ADB',
        'exported_receivers': 'ADB',
        'exported_providers': 'ADB',
        'implicit_intents': 'ADB',
        'intent_spoofing': 'ADB',
        'sensitive_intents': 'ADB',
        'sticky_broadcasts': 'ADB',
        'pending_intent_misuse': 'ADB',
        'task_hijacking': 'ADB',
        'deep_link_vulnerabilities': 'ADB',
        'exported_without_protection': 'ADB'
    },
    'insecure_webview': {
        'javascript_interface': 'ADB',
        'untrusted_content': 'ADB',
        'file_access': 'ADB',
        'ssl_errors_ignored': 'ADB',
        'javascript_enabled': 'ADB'
    },
    'hardcoded_secrets': {
        'api_keys': 'External APK',
        'tokens': 'External APK',
        'passwords': 'External APK',
        'database_credentials': 'External APK',
        'encryption_keys': 'External APK',
        'webhook_urls': 'External APK',
        'base64_encoded': 'External APK',
        'backend_urls': 'External APK',
        'embedded_certificates': 'External APK'
    },
    'insecure_network': {
        'cleartext_traffic': 'External APK',
        'accept_all_certs': 'External APK',
        'missing_cert_pinning': 'External APK',
        'weak_hostname_verifier': 'External APK',
        'insecure_trust_manager': 'External APK'
    },
    'input_validation': {
        'sql_injection': 'ADB',
        'path_traversal': 'ADB',
        'command_injection': 'ADB',
        'xss': 'ADB',
        'unsafe_deserialization': 'ADB'
    },
    'code_debug_config': {
        'debuggable_enabled': 'ADB',
        'backup_allowed': 'ADB',
        'test_code_paths': 'External APK',
        'no_obfuscation': 'External APK',
        'vulnerable_native_libs': 'External APK'
    },
    'side_channel_leakage': {
        'clipboard_data': 'ADB',
        'timing_leaks': 'External APK',
        'intent_sniffing': 'ADB',
        'memory_leaks': 'External APK'
    },
    'insecure_third_party': {
        'outdated_sdks': 'External APK',
        'pii_leakage': 'External APK',
        'weak_sdk_auth': 'External APK'
    },
    'local_auth_session': {
        'insecure_token_storage': 'ADB',
        'session_ids_exposed': 'ADB',
        'weak_biometric_logic': 'ADB'
    },
    'root_detection_bypass': {
        'weak_root_detection': 'External APK',
        'client_only_detection': 'External APK',
        'easily_bypassable': 'External APK'
    },
    'ssl_pinning_bypass': {
        'improper_pinning': 'External APK',
        'client_only_pinning': 'External APK',
        'bypassable_pinning': 'External APK'
    }
}

# ICC-SPECIFIC LOGIC: Disable false positive filtering for ICC vulnerabilities
def is_icc_vulnerability(category: str, subcategory: str) -> bool:
    """Check if this is an ICC vulnerability that should NEVER be filtered out."""
    return category == 'insecure_icc'

def is_false_positive(category: str, subcategory: str, line_content: str, context: str) -> bool:
    """
    Enhanced false positive detection that NEVER filters out ICC vulnerabilities.
    ICC vulnerabilities are critical and should always be reported.
    """
    # NEVER filter out ICC vulnerabilities - they are always real
    if is_icc_vulnerability(category, subcategory):
        return False
    
    # For non-ICC vulnerabilities, apply minimal filtering
    line_lower = line_content.lower()
    
    # Skip obvious comments
    if line_content.strip().startswith('//') or line_content.strip().startswith('#'):
        return True
    
    # Skip if it's clearly a false positive
    if any(word in line_lower for word in ['example', 'test', 'sample', 'demo', 'placeholder']):
        return True
    
    return False

def get_vulnerability_title(category: str, subcategory: str) -> str:
    """Get the vulnerability title for a given category and subcategory."""
    return VULNERABILITY_TITLES.get(category, {}).get(subcategory, f"{category.replace('_', ' ').title()} - {subcategory.replace('_', ' ').title()}")

def get_exploitation_method(category: str, subcategory: str) -> str:
    """Get the exploitation method for a given category and subcategory."""
    return EXPLOITATION_METHODS.get(category, {}).get(subcategory, "Unknown")

def get_exploitation_scenario(category: str, subcategory: str, package_name: str = "com.example.app", component_name: str = "MainActivity") -> str:
    """Generate detailed exploitation scenario for each vulnerability type."""
    
    # ICC vulnerabilities - detailed exploitation scenarios
    if category == 'insecure_icc':
        if subcategory == 'exported_activities':
            return f"An attacker can launch the exported activity '{component_name}' in package '{package_name}' without proper authentication. This allows unauthorized access to sensitive functionality, potential data theft, or privilege escalation. The attacker can craft malicious intents to trigger unintended actions or access protected resources."
        elif subcategory == 'exported_services':
            return f"An attacker can bind to the exported service '{component_name}' in package '{package_name}' and potentially execute privileged operations. This could lead to unauthorized data access, service hijacking, or denial of service attacks by overwhelming the service with malicious requests."
        elif subcategory == 'exported_receivers':
            return f"An attacker can send malicious broadcasts to the exported receiver '{component_name}' in package '{package_name}', potentially triggering unintended actions or accessing sensitive data. This could be exploited for privilege escalation or data exfiltration."
        elif subcategory == 'exported_content_providers':
            return f"An attacker can query the exported content provider '{component_name}' in package '{package_name}' to access sensitive data stored in the app's database. This could lead to information disclosure, including user credentials, personal data, or business logic exposure."
        elif subcategory == 'pending_intent_misuse':
            return f"The PendingIntent in '{component_name}' of package '{package_name}' is mutable and can be hijacked by malicious apps. Attackers can modify the intent data to perform actions on behalf of the vulnerable app, potentially leading to unauthorized operations or data manipulation."
        elif subcategory == 'task_hijacking':
            return f"Task hijacking vulnerability in '{component_name}' of package '{package_name}' allows malicious apps to overlay the legitimate app's interface. Attackers can create phishing screens that mimic the real app to steal user credentials or perform unauthorized transactions."
        else:
            return f"ICC vulnerability in '{component_name}' of package '{package_name}' allows unauthorized access to app components. This could lead to privilege escalation, data theft, or unauthorized functionality execution."
    
    # Other vulnerability categories with detailed scenarios
    elif category == 'insecure_webview_usage':
        return f"JavaScript is enabled in WebView components of '{component_name}' in package '{package_name}', allowing potential XSS attacks. Attackers can inject malicious JavaScript code to steal user data, perform unauthorized actions, or access sensitive information through the WebView interface."
    
    elif category == 'hardcoded_secrets':
        return f"Hardcoded secrets in '{component_name}' of package '{package_name}' expose sensitive information like API keys, passwords, or encryption keys. Attackers can extract these secrets from the decompiled APK to gain unauthorized access to backend services, decrypt sensitive data, or impersonate the legitimate app."
    
    elif category == 'insecure_data_storage':
        return f"Insecure data storage in '{component_name}' of package '{package_name}' stores sensitive information without proper encryption. Attackers with physical access to the device or root privileges can extract stored data, including user credentials, personal information, or business data, leading to privacy violations and potential identity theft."
    
    elif category == 'insecure_network_communication':
        return f"Insecure network communication in '{component_name}' of package '{package_name}' transmits sensitive data over unencrypted channels. Attackers can intercept network traffic through man-in-the-middle attacks to steal user credentials, personal data, or business information, potentially leading to account compromise and data breaches."
    
    elif category == 'input_validation_code_injection':
        return f"Insufficient input validation in '{component_name}' of package '{package_name}' allows code injection attacks. Attackers can inject malicious input to execute arbitrary code, access sensitive data, or perform unauthorized operations, potentially leading to complete system compromise."
    
    elif category == 'code_debug_configuration_issues':
        return f"Debug configuration enabled in '{component_name}' of package '{package_name}' exposes sensitive debugging information and allows unauthorized access to app internals. Attackers can use debugging tools to analyze app behavior, extract sensitive data, or modify app functionality for malicious purposes."
    
    elif category == 'side_channel_leakage_issues':
        return f"Side-channel vulnerabilities in '{component_name}' of package '{package_name}' leak sensitive information through timing, power consumption, or other indirect channels. Attackers can analyze these side channels to extract encryption keys, user passwords, or other sensitive data without direct access to the data itself."
    
    elif category == 'insecure_third_party_sdk_usage':
        return f"Insecure third-party SDK usage in '{component_name}' of package '{package_name}' introduces vulnerabilities from external libraries. Attackers can exploit known vulnerabilities in outdated or insecure SDKs to gain unauthorized access, steal data, or perform malicious actions within the app context."
    
    elif category == 'poor_local_authentication_session_handling':
        return f"Poor authentication and session handling in '{component_name}' of package '{package_name}' allows attackers to bypass authentication mechanisms, hijack user sessions, or maintain unauthorized access. This could lead to account takeover, unauthorized data access, or privilege escalation attacks."
    
    elif category == 'root_detection_jailbreak_detection_bypass':
        return f"Weak root/jailbreak detection in '{component_name}' of package '{package_name}' can be easily bypassed by attackers. This allows malicious apps to run with elevated privileges, access sensitive data, or perform unauthorized operations that would normally be restricted on compromised devices."
    
    elif category == 'ssl_pinning_implementation_bypass':
        return f"SSL pinning implementation in '{component_name}' of package '{package_name}' can be bypassed through code modification or hooking. Attackers can intercept encrypted communications, perform man-in-the-middle attacks, or steal sensitive data transmitted over supposedly secure channels."
    
    return f"Security vulnerability detected in '{component_name}' of package '{package_name}'. This vulnerability could potentially allow attackers to gain unauthorized access, steal sensitive data, or perform malicious actions. Detailed analysis is recommended to assess the specific impact and required remediation steps."

def get_patterns() -> Dict[str, Any]:
    """Get all vulnerability patterns."""
    return REGEX_PATTERNS

def get_framework_patterns() -> Dict[str, Any]:
    """Get framework detection patterns."""
    return FRAMEWORK_PATTERNS

def get_enhanced_patterns() -> Dict[str, Any]:
    """Get enhanced vulnerability patterns with exploit information."""
    return ENHANCED_VULNERABILITY_PATTERNS

def get_exploit_for_vulnerability(category: str, subcategory: str, context: str = "", package_name: str = "com.target.app") -> Dict[str, Any]:
    """Get exploit payload for a specific vulnerability."""
    return ExploitPayloadGenerator.get_exploit_payload(category, subcategory, context, package_name)

def is_enhanced_false_positive(category: str, subcategory: str, matched_text: str) -> bool:
    """Enhanced false positive detection for 100% accuracy."""
    # NEVER filter out ICC vulnerabilities - they are always real
    if is_icc_vulnerability(category, subcategory):
        return False
    
    if category in ENHANCED_VULNERABILITY_PATTERNS and subcategory in ENHANCED_VULNERABILITY_PATTERNS[category]:
        patterns = ENHANCED_VULNERABILITY_PATTERNS[category][subcategory]
        
        # Check false positive indicators
        for indicator in patterns.get('false_positive_indicators', []):
            if re.search(indicator, matched_text, re.IGNORECASE):
                return True
        
        # Additional context-based checks
        if '//' in matched_text or '/*' in matched_text:
            return True  # Commented code
        
        if 'test' in matched_text.lower() or 'demo' in matched_text.lower():
            return True  # Test/demo code
    
    return False

def get_confidence_score(category: str, subcategory: str, matched_text: str) -> float:
    """Get confidence score for vulnerability detection."""
    # ICC vulnerabilities always have high confidence
    if is_icc_vulnerability(category, subcategory):
        return 0.95
    
    if category in ENHANCED_VULNERABILITY_PATTERNS and subcategory in ENHANCED_VULNERABILITY_PATTERNS[category]:
        base_confidence = ENHANCED_VULNERABILITY_PATTERNS[category][subcategory].get('confidence', 0.7)
        
        # Adjust based on context
        if is_enhanced_false_positive(category, subcategory, matched_text):
            return 0.0
        
        return base_confidence
    
    return 0.7  # Default confidence

def extract_package_name_from_manifest(manifest_content: str) -> str:
    """Extract package name from AndroidManifest.xml content."""
    package_match = re.search(r'package\s*=\s*["\']([^"\']+)["\']', manifest_content)
    if package_match:
        return package_match.group(1)
    return "com.target.app"

def extract_component_names_from_manifest(manifest_content: str) -> Dict[str, List[str]]:
    """Extract component names from AndroidManifest.xml for better exploit generation."""
    components = {
        'activities': [],
        'services': [],
        'receivers': [],
        'providers': []
    }
    
    # Extract activities
    activity_matches = re.findall(r'<activity[^>]*android:name\s*=\s*["\']([^"\']+)["\']', manifest_content)
    components['activities'].extend(activity_matches)
    
    # Extract services
    service_matches = re.findall(r'<service[^>]*android:name\s*=\s*["\']([^"\']+)["\']', manifest_content)
    components['services'].extend(service_matches)
    
    # Extract receivers
    receiver_matches = re.findall(r'<receiver[^>]*android:name\s*=\s*["\']([^"\']+)["\']', manifest_content)
    components['receivers'].extend(receiver_matches)
    
    # Extract providers
    provider_matches = re.findall(r'<provider[^>]*android:name\s*=\s*["\']([^"\']+)["\']', manifest_content)
    components['providers'].extend(provider_matches)
    
    return components

def generate_icc_exploit_commands(package_name: str, component_type: str, component_name: str) -> List[str]:
    """Generate multiple ICC exploit commands for comprehensive testing."""
    commands = []
    
    if component_type == 'activity':
        # Basic activity launch
        commands.append(f'adb shell am start -n {package_name}/{component_name}')
        # Activity with extras
        commands.append(f'adb shell am start -n {package_name}/{component_name} --es "payload" "exploit" --ez "debug" true')
        # Activity with data URI
        commands.append(f'adb shell am start -n {package_name}/{component_name} -d "http://malicious.com/exploit"')
        
    elif component_type == 'service':
        # Basic service start
        commands.append(f'adb shell am startservice -n {package_name}/{component_name}')
        # Service with extras
        commands.append(f'adb shell am startservice -n {package_name}/{component_name} --es "data" "exploit_payload"')
        # Service binding
        commands.append(f'adb shell am bindservice -n {package_name}/{component_name}')
        
    elif component_type == 'receiver':
        # Basic broadcast
        commands.append(f'adb shell am broadcast -n {package_name}/{component_name}')
        # Boot completed broadcast
        commands.append(f'adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n {package_name}/{component_name}')
        # Custom action broadcast
        commands.append(f'adb shell am broadcast -a com.custom.action.EXPLOIT -n {package_name}/{component_name}')
        
    elif component_type == 'provider':
        # Basic content query
        commands.append(f'adb shell content query --uri content://{package_name}.{component_name}/data')
        # Content query with projection
        commands.append(f'adb shell content query --uri content://{package_name}.{component_name}/data --projection "*"')
        # Content query with selection
        commands.append(f'adb shell content query --uri content://{package_name}.{component_name}/data --selection "1=1"')
        # Content insert
        commands.append(f'adb shell content insert --uri content://{package_name}.{component_name}/data --bind name:s:exploit')
        
    return commands

def get_comprehensive_exploit_payload(category: str, subcategory: str, package_name: str = "com.target.app", component_name: str = "MainActivity") -> Dict[str, Any]:
    """Get comprehensive exploit payload with multiple command options."""
    base_exploit = get_exploit_for_vulnerability(category, subcategory, "", package_name)
    
    # For ICC vulnerabilities, add multiple command options
    if category == 'insecure_icc':
        base_exploit['multiple_commands'] = generate_icc_exploit_commands(package_name, subcategory.replace('exported_', ''), component_name)
        base_exploit['exploit_complexity'] = 'HIGH'
        base_exploit['testing_tools'] = ['Drozer', 'Intent Fuzzer APK', 'ADB', 'Burp Suite']
        base_exploit['mitigation'] = 'Set android:exported="false" or add proper permissions'
    else:
        base_exploit['exploit_complexity'] = 'MEDIUM'
        base_exploit['testing_tools'] = ['ADB', 'APK Decompiler', 'Network Tools']
    
    return base_exploit
